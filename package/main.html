<html><head><title>Duet WebGL - AP</title><script src="bower_components/webcomponentsjs/webcomponents-lite.min.js"></script><link href="elements.html" rel="import"/><style is="custom-style" include="iron-flex iron-flex-alignment iron-flex-factors iron-positioning"></style><link rel="stylesheet" async="async" href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Poiret+One|Roboto"/><script src="bower_components/phaser/build/phaser.min.js"></script></head><body class="fullbleed"><style>html,body,head {margin:0;padding:0;border:0;background: #1D1D1D;overflow:hidden}
h1,h2,h3 {font-family: "Poiret One";font-weight:200}
canvas {height:100%;width:100%}</style><style is="custom-style">paper-toolbar {background-color: transparent;position:absolute;top:0;left:0;width:100%}</style><template id="app" is="dom-bind"><audio src="[[track]]" loop="loop" autoplay="autoplay"></audio><paper-toolbar><h1>Duet</h1><div class="flex"></div><h3>Score: [[round(score)]]</h3></paper-toolbar></template><script>Array.prototype.make = function(s){return Array.apply(0, Array(s)).map((_,i) => i)}
Number.prototype.rangeRandom = function(min,max){return Math.random() * (max - min) + min}
String.prototype.titleCase = function(){
    const str = this.toLowerCase().split(' ');
    for (var i = 0; i < str.length; i++) {
        str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1); 
    }
    return str.join(' ');
}
var t = document.querySelector("#app"), game,bs,wl;
t.w_spin = []
t.score = 0
t.level = 1
t.track = "public/theme.ogg"
t.round = n => Math.round(n)
//t.getLevel = l => require("../levels/"+l+".json")
t.getLevel = _ => ({
    "walls": [
        {"type": "left"},
        {"type": "center"},
        {"type": "spin"},
        {"type": "center"},
        {"type": "spin", "dir": 1},
        {"type": "left"},
        {"type": "right"},
        {"type": "left"},
        {"type": "center"},
    ],
    "track": "/public/lv1.ogg"
})
t.setScore = s => {
    clearInterval(t.curInt)
    const seg = {in: (s - t.score)/30, f: s}
    const neg = seg.in<0
    t.curInt = setInterval(_ => {t.score=t.score+seg.in;if (neg?t.score <= seg.f:t.score >= seg.f){t.score=seg.f;clearInterval(t.curInt)}},30)
}
t.gameSetup = function(game){}
t.gameSetup.prototype = {
    preload: function(){
        const H_OFFSET = game.height*.875, W_OFFSET = game.world.centerX, PAD = 150, BALL_RAD = .22
        //game.stage.backgroundColor = 'rgba(0,0,0,.9)'
        const MakeRect = (w,h) => {
            var drawnObject;
            var bmd = game.add.bitmapData(w, h);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, w, h);
            bmd.ctx.fillStyle = '#ffffff';
            bmd.ctx.closePath();
            bmd.ctx.fill();return bmd
        }
        const MakeCircle = (color,sz) => {
            sz = sz || 10
            const bmd = game.add.bitmapData(sz*2, sz*2); // Draw circle 
            bmd.ctx.fillStyle = color;
            bmd.ctx.beginPath();
            bmd.ctx.arc(sz, sz, sz, 0, Math.PI * 2, false);
            bmd.ctx.closePath();
            bmd.ctx.fill();return bmd
        }
        //=Circle=======================|
        var graphics = game.add.graphics(W_OFFSET, H_OFFSET);
        graphics.lineStyle(1, 0x868686);
        this.disk = graphics.arc(0,0, W_OFFSET*BALL_RAD, 0, Math.PI*2, false);
        //=Export=======================|
        this.config = {
            PAD: PAD,
            moved: 0,
            W_OFFSET: W_OFFSET,
            H_OFFSET: H_OFFSET,
            BALL_RAD: BALL_RAD,
            MakeRect: MakeRect,
            MakeCircle: MakeCircle,
        }
    },
    keyBindings: function(){
        this.cursors = game.input.keyboard.createCursorKeys();
        const kb=Phaser.Keyboard;
        var left = game.input.keyboard.addKey(kb.LEFT)
        var right = game.input.keyboard.addKey(kb.RIGHT)
        game.input.keyboard.addKey(kb.r).onDown.add(this.resetGame, this)
        left.onDown.add(this.spinLeft, this)
        right.onDown.add(this.spinRight, this)
        left.onUp.add(this.spinLeftDone, this)
        right.onUp.add(this.spinRightDone, this)
    },
    spinLeft: function(){bs.lPressed = !!(bs.rotate = 'left')},
    spinRight: function(){bs.rPressed = !!(bs.rotate = 'right')},
    spinRightDone: function(){bs.rPressed = false;bs.rotate = bs.lPressed && 'left'},
    spinLeftDone: function(){bs.lPressed = false;bs.rotate = bs.rPressed && 'right'},
    create: function(){
        //=VIEW=============================================================|
        game.scale.pageAlignHorizontally = game.scale.pageAlignVertically = true;
        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        game.speed = 4
        //=KEY/INIT=========================================================|
        this.keyBindings()
        const ph = game.physics
        ph.startSystem(Phaser.Physics.P2JS)
        ph.p2.setImpactEvents(true);ph.p2.restitution = 0.8
        this.BallCG = ph.p2.createCollisionGroup();this.WallCG = ph.p2.createCollisionGroup();
        //ph.p2.updateBoundsCollisionGroup(); //Causes mayhem
        //=MAKE=============================================================|
        const c = this.config;
        this.balls = bs = game.add.group();
        this.walls = wl = game.add.group();
        this.particlesGroup = game.add.group();
        //====Physics=======================|
        ([wl,bs,this.particlesGroup]).forEach(gr => {gr.enableBody = gr.enableBodyDebug = true;gr.physicsBodyType = Phaser.Physics.P2JS})
        //====Sprites=======================|
        this.ballX = bs.create(c.W_OFFSET*(1-c.BALL_RAD), c.H_OFFSET, c.MakeCircle('#FF0000',11));
        this.ballY = bs.create(c.W_OFFSET*(1+c.BALL_RAD), c.H_OFFSET, c.MakeCircle('#2196F3',11));
        this.ballX.tint = 0xFF0000;this.ballY.tint = 0x2196F3
        this.makeWalls(t.getLevel(t.level),this);
        //=ANIMATE==========================================================|
        const ANIM_ARGS = delay => [250, Phaser.Easing.Linear.None, true, 0, delay, true]
        wl.children.forEach((ch,i) => game.add.tween(ch.scale).to({
            x: 1.05, y: 1.15
        }, ...ANIM_ARGS(250*i)));
        //game.add.tween(wl.position).to({
        //    x: -100, y: -200
        //}, ...ANIM_ARGS);
        //if (t.w_spin.length) {
        //    t.w_spin.forEach(w => {const d=w[0],e=w[1];game.add.tween(e).to({
        //        angle: (d?'+':'-')+'360'
        //    }, 8000, Phaser.Easing.Linear.None, true, 0, 1000, false)})
        //}
        //=PHYSICS/COLLIDE==========================================================|
        //game.physics.enable(wl, Phaser.Physics.P2);
        //game.physics.enable(bs, Phaser.Physics.P2);
        [this.ballX,this.ballY].forEach(b => {
            b.body.setCircle(b.width/2)
            b.body.fixedRotation = true
            b.body.setCollisionGroup(this.BallCG)
            b.body.collides([this.WallCG,this.BallCG])
            b.anchor.set(.5,.5);b.body.kinematic=true
            //b.body.collides(this.WallCG,this.ballSplat)
            b.body.createGroupCallback(this.WallCG,this.ballSplat,this)
        })
        app.c = this
        t.wlPos = wl.children.map(w => ({x: w.position.x,y:w.position.y,deg:w.body.angle}))
        //wl.children.forEach(w => {const b = w.body;b.velocity.y = 0})
        wl.setAll("body.velocity.y",0)
        game.camera.follow(this.center)
    },
    makeWalls: function(d,cg) {
        //=MAKE=WALLS================================================|
        const c = this.config;const W_W = c.W_OFFSET*1.05
        t.track = d.track
        const mk_sprite = (gr,ty,i) => {
            const w_sprite = (w,h) => c.MakeRect(w,h)
            const w_x = (t,w) => ({left: 0+w/2, right: game.width-w/2, center: c.W_OFFSET, spin: c.W_OFFSET}[t])
            const tra = {left: [W_W,30],right: [W_W,30],center: [c.W_OFFSET*.15,c.W_OFFSET*.15],spin: [c.W_OFFSET*.45,30]}
            const conf = tra[ty], h_off = c.H_OFFSET/4
            if (!conf) {return}
            const w = conf[0], h = conf[1]
            const sprite = w_sprite(w,h)
            const ob = gr.create(w_x(ty,w),h_off-i*c.PAD, sprite)
            ob.body.setRectangle(w,h)
            return ob
        }
        //const block = s => c.MakeRect(W_W,s||30)
        d.walls.forEach((w,i) => {
            const W = mk_sprite(wl,w.type,i);if (!W) {return}
            W.body.setCollisionGroup(cg.WallCG)
            //W.body.kinematic=true // MAKES PASS_THRU
            W.body.collides([cg.WallCG,cg.BallCG])
            if (w.type == "spin") {W.body.angle = 10*i;t.w_spin.push([w.dir,W])}
        })
        //wl.create(0,-30-1*c.PAD, c.MakeRect(W_W,30))
        //wl.create(W_W*.9,-W_W*.15*2-(2-.2)*c.PAD, c.MakeRect(W_W*.1*2,W_W*.15*2))
        //wl.create(0,-30-3*c.PAD, c.MakeRect(W_W,30))
        //wl.create(0,-30-4*c.PAD, c.MakeRect(W_W,30))
        //wl.create(game.width-W_W,-30-5*c.PAD, c.MakeRect(W_W,30))
    },
    update: function(){
        //bs.children.forEach(b => b.body.setZeroVelocity())
        wl.children.forEach(b => b.body.setZeroVelocity())
        wl.children.forEach(b => b.body.moveDown(200))
        const c = this.config
        c.moved+=200
        //=MOVEMENT==================================|
        if (bs.rotate) {bs.children.forEach(ch => {
            var ang = this.ballX.body.angle+game.speed*(bs.rotate=="right"?1:-1)
            const rad = c.W_OFFSET*c.BALL_RAD,b = ch.body,tR=Math.PI/180, isY = ch==this.ballY
            const I = isY?-1:1
            ch.body.angle = ang+(isY?180:0)
            b.x = c.W_OFFSET-rad*Math.cos(ang*tR)*I
            b.y = c.H_OFFSET-rad*Math.sin(ang*tR)*I
        })}
        if (t.w_spin.length) {
            t.w_spin.forEach(w => {
                w[1].body.fixedRotation = false;
                w[1].body.angle+=(w[0] || -1)*.95
            })
        }
        if (wl.children.slice(-1)[0].position.y > c.H_OFFSET && !game.complete) {
            game.complete = true
            const tex = game.add.text(0, 0, "You have completed the Level", {font: "40px 'Poiret One'", fill: "#FFFFFF", align: "center"});
            tex.position.set(Math.floor(c.W_OFFSET - tex.width/2),Math.floor(game.height/2-tex.height/2))
            t.setScore(t.score+50)
            wl.children.forEach(w => w.body.velocity.y = 0)
        }
    },
    resetGame: function(){game.state.start("PlayGame",true,true)},
    ballSplat: function(x,y){
        this.sprinkleDeath(x.sprite)
        wl.children.forEach(b => (b.position.y-=this.config.moved))
        //this.config.moved=0
        //wl.children.forEach((w,i) => w.position.set(t.wlPos[i].x,t.wlPos[i].y))
    },
    sprinkleDeath: function(x){
        const c = this.config, p = x.position,color = '#'+Phaser.Color.componentToHex(x.tint),prt = this.particlesGroup;
        ([]).make(15).forEach(i => {
            var ob = prt.getFirstExists(false) || prt.create(0, 0, c.MakeCircle(color,(0).rangeRandom(1,4)))
            const b = ob.body;
            ob.reset(p.x,p.y)
            b.velocity.x = (0).rangeRandom(-10, 10)
            b.velocity.y = 200
            b.data.gravityScale = 100
            b.gravity.y = 50
            b.mass = .01
            ob.anchor.set(.5,.5)
            ob.lifespan = 3000
            ob.alpha = .8
        })
        x.kill();
    },
    render: function(){game.debug.body(wl)}
}
window.onload = function() {
    game = t.g = new Phaser.Game(640, 960, Phaser.AUTO, "", undefined, true);
    game.state.add("PlayGame", t.gameSetup);
    game.state.start("PlayGame");
}</script></body></html>