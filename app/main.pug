html
    head
        title Duet WebGL - AP
        script(src="bower_components/webcomponentsjs/webcomponents-lite.min.js")
        link(href="elements.html", rel="import")
        style(is="custom-style",include="iron-flex iron-flex-alignment iron-flex-factors iron-positioning")
        link(rel="stylesheet",async,href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Poiret+One|Roboto")
        script(src="bower_components/phaser/build/phaser.min.js")
    body.fullbleed
        style.
            html,body,head {margin:0;padding:0;border:0;background: #1D1D1D;overflow:hidden}
            h1,h2,h3 {font-family: "Poiret One";font-weight:200}
            canvas {height:100%;width:100%}
        style(is="custom-style").
            paper-toolbar {background-color: transparent;position:absolute;top:0;left:0;width:100%}
        template#app(is="dom-bind")
            audio(src="[[track]]",loop,autoplay)
            paper-toolbar
                h1 Duet
                .flex
                h3 Score: [[round(score)]]
        script.
            var t = document.querySelector("#app"), game,bs,wl;
            t.w_spin = []
            t.score = 0
            t.level = 1
            t.track = "public/theme.ogg"
            t.round = n => Math.round(n)
            //t.getLevel = l => require("../levels/"+l+".json")
            t.getLevel = _ => ({
                "walls": [
                    {"type": "left"},
                    {"type": "center"},
                    {"type": "spin"},
                    {"type": "spin", "dir": 1},
                    {"type": "left"},
                    {"type": "right"},
                    {"type": "left"},
                    {"type": "center"},
                ],
                "track": "/public/lv1.ogg"
            })
            t.setScore = s => {
                clearInterval(t.curInt)
                const seg = {in: (s - t.score)/30, f: s}
                const neg = seg.in<0
                t.curInt = setInterval(_ => {t.score=t.score+seg.in;if (neg?t.score <= seg.f:t.score >= seg.f){t.score=seg.f;clearInterval(t.curInt)}},30)
            }
            t.gameSetup = function(game){}
            t.gameSetup.prototype = {
                preload: function(){
                    const H_OFFSET = game.height*.875, W_OFFSET = game.world.centerX, PAD = 150
                    //game.stage.backgroundColor = 'rgba(0,0,0,.9)'
                    const MakeRect = (w,h) => {
                        var drawnObject;
                        var bmd = game.add.bitmapData(w, h);
                        bmd.ctx.beginPath();
                        bmd.ctx.rect(0, 0, w, h);
                        bmd.ctx.fillStyle = '#ffffff';
                        bmd.ctx.closePath();
                        bmd.ctx.fill();return bmd
                    }
                    const MakeCircle = (color,sz) => {
                        sz = sz || 10
                        const bmd = game.add.bitmapData(sz*2, sz*2); // Draw circle 
                        bmd.ctx.fillStyle = color;
                        bmd.ctx.beginPath();
                        bmd.ctx.arc(sz, sz, sz, 0, Math.PI * 2, false);
                        bmd.ctx.closePath();
                        bmd.ctx.fill();return bmd
                    }
                    var graphics = game.add.graphics(W_OFFSET, H_OFFSET);
                    graphics.lineStyle(1, 0x868686);
                    this.disk = graphics.arc(0,0, W_OFFSET*.2, 0, Math.PI*2, false);
                    this.balls = bs = game.add.group()
                    bs.position.set(W_OFFSET, H_OFFSET)
                    this.ballX  = bs.create(-W_OFFSET*.2, 0, MakeCircle('#FF0000'));
                    this.ballY  = bs.create(W_OFFSET*.2, 0, MakeCircle('#2196F3'));
                    this.ballX.tint = 0xFF0000;this.ballY.tint = 0x2196F3
                    console.log(this.ballX.boundsPadding)
                    this.walls  = wl = game.add.group()
                    wl.position.set(0, H_OFFSET/3);
                    this.config = {
                        PAD: PAD,
                        W_OFFSET: W_OFFSET,
                        H_OFFSET: H_OFFSET,
                        MakeRect: MakeRect,
                    }
                },
                keyBindings: function(){
                    this.cursors = game.input.keyboard.createCursorKeys();
                    const kb=Phaser.Keyboard;
                    var left = game.input.keyboard.addKey(kb.LEFT)
                    var right = game.input.keyboard.addKey(kb.RIGHT)
                    game.input.keyboard.addKey(kb.r).onDown.add(this.resetGame, this)
                    left.onDown.add(this.spinLeft, this)
                    right.onDown.add(this.spinRight, this)
                    left.onUp.add(this.spinLeftDone, this)
                    right.onUp.add(this.spinRightDone, this)
                },
                spinLeft: function(){bs.lPressed = !!(bs.rotate = 'left')},
                spinRight: function(){bs.rPressed = !!(bs.rotate = 'right')},
                spinRightDone: function(){bs.rPressed = false;bs.rotate = bs.lPressed && 'left'},
                spinLeftDone: function(){bs.lPressed = false;bs.rotate = bs.rPressed && 'right'},
                create: function(){
                    this.keyBindings()
                    game.scale.pageAlignHorizontally = game.scale.pageAlignVertically = true;
                    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                    game.speed = 4
                    this.makeWalls(t.getLevel(t.level))
                    //===========================================================|
                    game.add.tween(wl.scale).to({
                        x: 1.02, y: 1.02
                    }, 250, Phaser.Easing.Linear.None, true, 0, 1000, true)
                    if (t.w_spin.length) {
                        t.w_spin.forEach(w => {const d=w[0],e=w[1];game.add.tween(e).to({
                            angle: (d?'+':'-')+'360'
                        }, 8000, Phaser.Easing.Linear.None, true, 0, 1000, false)})
                    }
                    //===========================================================|
                    game.physics.enable(wl, Phaser.Physics.ARCADE);
                    game.physics.enable(bs, Phaser.Physics.ARCADE);
                    [this.ballX,this.ballY].forEach(b => {b.anchor.set(.5,.5);b.body.immovable=true})
                    t.wlPos = wl.children.map(w => ({x: w.position.x,y:w.position.y}))
                    wl.children.forEach(w => {const b = w.body;b.velocity.y = 180;b.immovable=true})
                    game.camera.follow(this.center)
                },
                makeWalls: function(d) {
                    //=MAKE=WALLS================================================|
                    const c = this.config;const W_W = c.W_OFFSET*1.05
                    t.track = d.track
                    const w_sprite = {
                        left: c.MakeRect(W_W,30),
                        right: c.MakeRect(W_W,30),
                        center: c.MakeRect(50,50),
                        spin: c.MakeRect(c.W_OFFSET*.45,30),
                    }, w_x = (t,s) => ({left: 0, right: game.width-s.width, center: c.W_OFFSET, spin: c.W_OFFSET}[t])
                    //const block = s => c.MakeRect(W_W,s||30)
                    d.walls.forEach((w,i) => {
                        const sprite = w_sprite[w.type];if (!sprite) {return}
                        const W = wl.create(w_x(w.type,sprite),-i*c.PAD, sprite)
                        W.anchor.set(0,.5)
                        if (w.type == "spin" || w.type == "center") {W.anchor.set(.5,.5)}
                        if (w.type == "spin") {W.angle=0;t.w_spin.push([w.dir,W])}
                    })
                    //wl.create(0,-30-1*c.PAD, c.MakeRect(W_W,30))
                    //wl.create(W_W*.9,-W_W*.15*2-(2-.2)*c.PAD, c.MakeRect(W_W*.1*2,W_W*.15*2))
                    //wl.create(0,-30-3*c.PAD, c.MakeRect(W_W,30))
                    //wl.create(0,-30-4*c.PAD, c.MakeRect(W_W,30))
                    //wl.create(game.width-W_W,-30-5*c.PAD, c.MakeRect(W_W,30))
                },
                update: function(){
                    const c = this.config
                    if (bs.rotate == "right") {bs.angle += game.speed} else if (bs.rotate == "left") {bs.angle -= game.speed}
                    game.physics.arcade.collide(bs,wl,this.ballSplat)
                    if (wl.children.slice(-1)[0].position.y > c.H_OFFSET && !game.complete) {
                        game.complete = true
                        const tex = game.add.text(0, 0, "You have completed the Level", {font: "40px 'Poiret One'", fill: "#FFFFFF", align: "center"});
                        tex.position.set(Math.floor(c.W_OFFSET - tex.width/2),Math.floor(game.height/2-tex.height/2))
                        t.setScore(t.score+50)
                        wl.children.forEach(w => w.body.velocity.y = 0)
                    }
                },
                resetGame: function(){game.state.start("PlayGame",true,true)},
                ballSplat: function(x,y){
                    y.tint = x.tint
                    wl.children.forEach((w,i) => w.position.set(t.wlPos[i].x,t.wlPos[i].y))
                },
            }
            window.onload = function() {
                game = t.g = new Phaser.Game(640, 960, Phaser.AUTO, "", undefined, true);
                game.state.add("PlayGame", t.gameSetup);
                game.state.start("PlayGame");
            }